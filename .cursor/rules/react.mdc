---
description: 
globs: 
alwaysApply: true
---
# üß± Criando Componentes React com Boas Pr√°ticas

Este guia padroniza a cria√ß√£o de componentes React no projeto, visando legibilidade, consist√™ncia e facilidade de manuten√ß√£o.

> ‚ö†Ô∏è **NUNCA use coment√°rios dentro do c√≥digo.**  
> Toda documenta√ß√£o e explica√ß√£o deve estar fora do escopo do c√≥digo, neste guia ou documenta√ß√£o externa. Coment√°rios no c√≥digo devem ser evitados completamente para manter o c√≥digo limpo e direto.

---

## üîÅ Evite C√≥digo Repetido

Evite repetir blocos de c√≥digo semelhantes. Sempre que poss√≠vel, **extraia dados para estruturas reutiliz√°veis** (como arrays ou objetos) e use `map` para gerar componentes dinamicamente. Isso reduz erros, facilita manuten√ß√£o e torna o c√≥digo mais escal√°vel.

### ‚ùå Errado (repeti√ß√£o manual de componentes)

```tsx
<nav className="px-4 space-y-1">
  <MenuItem
    icon={<FaHome size={20} />}
    text="Gest√£o"
    href="/gestao"
    active={true}
  />
  <MenuItem
    icon={<FaChartBar size={20} />}
    text="Planejamentos"
    href="/planejamentos"
  />
  <MenuItem
    icon={<FaLayerGroup size={20} />}
    text="Monitoramento"
    href="/monitoramento"
  />
  <MenuItem
    icon={<FaCheckSquare size={20} />}
    text="An√°lises"
    href="/analises"
  />
  <MenuItem
    icon={<FaFlag size={20} />}
    text="Auditoria"
    href="/auditoria"
  />
</nav>
```

Esse padr√£o √© dif√≠cil de manter e propenso a erro se algo mudar em todos os itens.

### ‚úÖ Certo (gerado dinamicamente via array)

```tsx
const menuItems = [
  { icon: <FaHome size={20} />, text: 'Gest√£o', href: '/gestao', active: true },
  { icon: <FaChartBar size={20} />, text: 'Planejamentos', href: '/planejamentos' },
  { icon: <FaLayerGroup size={20} />, text: 'Monitoramento', href: '/monitoramento' },
  { icon: <FaCheckSquare size={20} />, text: 'An√°lises', href: '/analises' },
  { icon: <FaFlag size={20} />, text: 'Auditoria', href: '/auditoria' }
]

<nav className="px-4 space-y-1">
  {menuItems.map(({ icon, text, href, active }) => (
    <MenuItem
      key={href}
      icon={icon}
      text={text}
      href={href}
      active={active}
    />
  ))}
</nav>
```

---

## üö´ Evite `export default` em componentes comuns

Evite usar `export default` para componentes **que n√£o s√£o pages do Next.js**. Prefira **exporta√ß√µes nomeadas** (`export const`). Isso melhora a autocompleta√ß√£o, refatora√ß√£o e reduz ambiguidade em imports.

### ‚ùå Errado (com `export default` em componente comum)

```tsx
const MenuItem = ({ text }: { text: string }) => {
  return <div>{text}</div>;
};

export default MenuItem;
```

export default dificulta a refatora√ß√£o autom√°tica e permite renomea√ß√µes inconsistentes no momento do import.

### ‚úÖ Certo (com export const)

```tsx
export const MenuItem = ({ text }: { text: string }) => {
  return <div>{text}</div>;
};
```

---

## üé® Importa√ß√£o de √çcones

Sempre utilize `as` para renomear √≠cones importados. Isso melhora a clareza do prop√≥sito do √≠cone no contexto onde ser√° usado, evitando nomes gen√©ricos e amb√≠guos no escopo do c√≥digo.

### ‚ùå Errado (import direto sem renomear)

```tsx
import { FaSignOutAlt } from "react-icons/fa";

<FaSignOutAlt />
```

O nome original do √≠cone pode n√£o ser claro no contexto. Al√©m disso, nomes gen√©ricos como FaXyz poluem o escopo e dificultam a leitura.

### ‚úÖ Certo (import com alias nomeado)

```tsx
import { FaSignOutAlt as SignOutIcon } from "react-icons/fa";

<SignOutIcon />
```

Dar um nome que reflita a inten√ß√£o de uso melhora a clareza e facilita a leitura e manuten√ß√£o do c√≥digo.

---

## üì• Imports do React

Evite importar o m√≥dulo completo do React apenas para usar tipos. Isso adiciona c√≥digo desnecess√°rio e vai contra as pr√°ticas modernas com o JSX autom√°tico (React 17+).

### ‚ùå Errado (importa√ß√£o desnecess√°ria de todo o React)

```tsx
import React from 'react';

type MenuItemProps = {
  icon: React.ReactNode;
  text: string;
  href: string;
  active?: boolean;
};
```

### ‚úÖ Certo (importando apenas o que precisa)

```tsx
import { ReactNode } from 'react';

type MenuItemProps = {
  icon: ReactNode;
  text: string;
  href: string;
  active?: boolean;
};
```

---

## üì¶ Modulariza√ß√£o de Componentes

Cada componente deve estar em seu **pr√≥prio arquivo**. Isso garante melhor organiza√ß√£o, facilita testes, reaproveitamento e leitura do c√≥digo. Evite agrupar m√∫ltiplos componentes em um √∫nico arquivo.

### ‚ùå Errado (v√°rios componentes no mesmo arquivo)

```tsx
// ButtonGroup.tsx
type ButtonProps = {
  text: string
  onClick: () => void
}

export const Button = ({ text, onClick }: ButtonProps) => {
  return <button onClick={onClick}>{text}</button>
}

export const SecondaryButton = ({ text }: { text: string }) => {
  return <button className="secondary">{text}</button>
}
```

Isso dificulta a reutiliza√ß√£o, leitura e testabilidade. N√£o √© escal√°vel.

### ‚úÖ Certo (um componente por arquivo)

```tsx
// components/Button.tsx
type ButtonProps = {
  text: string
  onClick: () => void
}

export const Button = ({ text, onClick }: ButtonProps) => {
  return <button onClick={onClick}>{text}</button>
}
```

## üß© Priorizando Componentes do Shadcn

Antes de criar um componente personalizado, verifique se o Shadcn j√° oferece uma solu√ß√£o adequada. Isso garante consist√™ncia visual, acessibilidade e reduz c√≥digo duplicado.

### ‚ùå Errado (criando componente personalizado sem necessidade)

```tsx
export const CustomButton = ({ text, onClick }: { text: string; onClick: () => void }) => {
  return (
    <button 
      className="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600"
      onClick={onClick}
    >
      {text}
    </button>
  )
}
```

### ‚úÖ Certo (utilizando componente do Shadcn)

```tsx
import { Button } from "@/components/ui/button"

export const ActionButton = ({ text, onClick }: { text: string; onClick: () => void }) => {
  return (
    <Button onClick={onClick}>
      {text}
    </Button>
  )
}
```

---

## Sempre utilize `return`

Mesmo em componentes simples, sempre utilize `return`. Isso facilita a inser√ß√£o de l√≥gica futura e evita erros.

### ‚ùå Errado (sem return)

```tsx
const Button = () => <button>Click</button>
```

### ‚úÖ Certo (com return)

```tsx
const Button = () => {
  return <button>Click</button>
}
```

Usar `return` garante que qualquer adi√ß√£o futura (como condicionais ou efeitos colaterais) seja mais simples de implementar.

---

## üßæ Tipando Props sem `React.FC`

Evite usar `React.FC` (ou `React.FunctionComponent`) por causa de infer√™ncias impl√≠citas como `children` obrigat√≥rio. Tipar as props diretamente √© mais claro e flex√≠vel.

### Exemplo com tipo definido manualmente

```tsx
type ButtonProps = {
  text: string
  onClick: () => void
}

const Button = ({ text, onClick }: ButtonProps) => {
  return <button onClick={onClick}>{text}</button>
}
```

### Exemplo usando `ComponentProps` (sem `React.FC`)

```tsx
const Input = ({ ...props }: ComponentProps<'input'>) => {
  return <input {...props} />
}
```

Essa abordagem funciona bem para reutilizar tipagens nativas do JSX/DOM ou de outros componentes personalizados.

---

## üìö Organiza√ß√£o dos Imports

Para manter a legibilidade e facilitar a manuten√ß√£o do c√≥digo, √© fundamental seguir uma ordem consistente nos imports. A ordem recomendada √©:

1. **Pacotes externos** (ex: `react`, `next`)
2. **Aliases** (ex: `@/components`, `@/utils`)
3. **Imports relativos** (`./`, `../`)

Seguindo essa estrutura, o c√≥digo fica mais organizado e f√°cil de navegar, especialmente em projetos maiores.

### ‚ùå Errado (imports desorganizados)

```tsx
import { useState } from 'react';
import {
  MenuItem,
  LogoLink,
  StorageCard,
  UserCard,
  mainMenuItems,
  footerMenuItems,
} from './menu';
import { usePathname } from 'next/navigation';
import { formatDate } from '@/utils/date';
```

- Os imports internos (./menu) est√£o misturados com pacotes externos.
- O alias (@/utils) est√° depois de um import relativo, o que n√£o √© o ideal.

### ‚úÖ Certo (organiza√ß√£o correta dos imports)

```tsx
import { useState } from 'react';
import { usePathname } from 'next/navigation';
import { formatDate } from '@/utils/date';
import {
  MenuItem,
  LogoLink,
  StorageCard,
  UserCard,
  mainMenuItems,
  footerMenuItems,
} from './menu';
```

- Pacotes externos v√™m primeiro.
- Depois, imports por alias **(@/)**.
- Por fim, imports relativos **(./)**.

---

## üö´ Por que n√£o usar `React.FC`

* Adiciona automaticamente o prop `children`, mesmo quando n√£o desejado
* Pode esconder problemas de tipagem
* Menos expl√≠cito e mais propenso a ambiguidade

Manter a tipagem pr√≥xima √† declara√ß√£o da fun√ß√£o torna o c√≥digo mais previs√≠vel e simples de evoluir.

Para componentes mais complexos (como os que usam `forwardRef` ou composi√ß√£o), siga os mesmos princ√≠pios: **use `return` e tipagem clara das props**.

Fique √† vontade para adaptar conforme o contexto, mas use essas diretrizes como base.

## üß© Uso correto do `react-hook-form` com `FormProvider`

Ao trabalhar com formul√°rios complexos no React usando `react-hook-form`, √© uma boa pr√°tica utilizar o `FormProvider` para compartilhar o contexto do formul√°rio entre os componentes. Isso mant√©m o c√≥digo mais limpo, organizado e reaproveit√°vel, especialmente quando usamos componentes customizados de input que acessam o formul√°rio via `useFormContext`.

---

### ‚ùå Errado (sem `FormProvider` e passando erros manualmente)

```tsx
const {
  register,
  handleSubmit,
  formState: { errors },
} = useForm<EmailSettingsFormData>({
  resolver: zodResolver(EmailSettingsSchema),
});

<form
  className="grid grid-cols-2 gap-4 p-8"
  onSubmit={handleSubmit(onSubmit)}
>
  <Input
    placeholder="sim"
    {...register("nome", { required: true })}
    error={errors.nome?.message}
  />
</form>
```

- Os m√©todos do formul√°rio est√£o sendo passados diretamente.
- O componente **<Input />** precisa receber manualmente o erro **(error={errors.nome?.message})**, o que aumenta a complexidade e o acoplamento entre o formul√°rio e os campos.

### ‚úÖ Certo (usando FormProvider + useFormContext())

```tsx
const methods = useForm<EmailSettingsFormData>({
  resolver: zodResolver(EmailSettingsSchema),
});

<FormProvider {...methods}>
  <form
    className="grid grid-cols-2 gap-4 p-8"
    onSubmit={methods.handleSubmit(onSubmit)}
  >
    <Input placeholder="Nome" {...register("nome", { required: true })} />
  </form>
</FormProvider>
```

- O **<Input />** se torna um componente desacoplado e reutiliz√°vel.
- Os erros s√£o tratados internamente usando **useFormContext()**.
- O formul√°rio principal fica mais limpo e sem l√≥gica duplicada.

## üîî Alertas com Toast (ShadCN)

Para exibir alertas, mensagens de sucesso, erro ou informa√ß√µes no projeto, **utilize o componente `toast` da biblioteca ShadCN**. Ele oferece uma interface elegante, consistente e de f√°cil integra√ß√£o com o design system do projeto.

---

### ‚úÖ Como usar corretamente

1. **Importe o hook `useToast`**:

```tsx
import { useToast } from "@/hooks/use-toast";
```

Utilize o toast onde for necess√°rio:

```tsx
const { toast } = useToast();

toast({
  title: "Scheduled: Catch up",
  description: "Friday, February 10, 2023 at 5:57 PM",
});
```

### üéØ Exemplo completo

```tsx
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";

export function AlertButton() {
  const { toast } = useToast();

  return (
    <Button
      onClick={() =>
        toast({
          title: "A√ß√£o realizada com sucesso!",
          description: "Seus dados foram salvos.",
        })
      }
    >
      Mostrar alerta
    </Button>
  );
}
```

### ‚ùå Evite usar alert() ou console.log() para notifica√ß√µes visuais

```tsx
// N√£o fa√ßa isso:
alert("Dados salvos com sucesso!");
console.log("Erro ao salvar dados");
```

## üßπ Verifica√ß√£o de Classes do Tema no Componente Base

Ao inspecionar o Figma ou usar um componente existente, sempre verifique se as **classes do tema** ou do **design system** j√° est√£o presentes no componente base. Isso evita a **duplica√ß√£o de classes** e mant√©m o c√≥digo mais limpo e organizado. Reutilizar o componente base garante **consist√™ncia** e facilita a **manuten√ß√£o** do projeto.

---

### ‚ùå Errado (Duplicando Classes no Componente Base)

**Componente `Button` Base (j√° com classes predefinidas no design system):**

```tsx
// Button.tsx (componente base)
export const Button = ({ children }: { children: React.ReactNode }) => {
  return (
    <button className="bg-blue-500 text-white p-3 rounded-md shadow-lg">
      {children}
    </button>
  );
};
```

Componente **CustomPage** (duplicando as classes no componente base):

```tsx
// CustomPage.tsx (utilizando o Button base, mas duplicando as classes)
import { Button } from "./Button";

export const CustomPage = () => {
  return (
    <div>
      <h1>P√°gina Personalizada</h1>
      <Button className="bg-blue-500 text-white p-3 rounded-md shadow-lg">Clique aqui</Button>
    </div>
  );
};
```

- Problema: O **CustomPage** est√° reaproveitando o componente **Button**, mas duplicou as classes definidas no componente base **Button** (**bg-blue-500**, **text-white**, **p-3**, **rounded-md**, **shadow-lg**). Isso cria duplica√ß√£o de estilos, pois o **Button** j√° possui essas classes internamente.
- **Consequ√™ncia**: Duplicar as classes torna o c√≥digo mais dif√≠cil de manter, j√° que qualquer modifica√ß√£o nos estilos do **Button** precisaria ser feita em v√°rios lugares, gerando inconsist√™ncia no design.

### ‚úÖ Certo (Usando o Componente Base Sem Duplicar as Classes)

```tsx
// Button.tsx (componente base)
import { Button } from "./Button";

const CustomPage = () => {
  return (
    <div>
      <h1>P√°gina Personalizada</h1>
      <Button>Clique aqui</Button>
    </div>
  );
};
```

- **Solu√ß√£o**: O componente **CustomPage** usa o componente **Button** base sem adicionar classes adicionais. O **Button** j√° est√° estilizado com as classes **bg-blue-500**, **text-white**, **p-3**, **rounded-md**, **shadow-lg** no componente base, portanto n√£o h√° necessidade de repetir essas classes no **CustomPage**.
- **Benef√≠cio**: O c√≥digo √© mais limpo, consistente e f√°cil de manter. Caso os estilos do **Button** precisem ser alterados, a mudan√ßa ser√° feita em um √∫nico lugar (no componente **Button**), garantindo uniformidade em todo o projeto.

---

## üî† Ordena√ß√£o Alfab√©tica nas Keywords de Import

Ao importar m√∫ltiplos itens de um mesmo m√≥dulo, **ordene-os em ordem alfab√©tica**. Isso facilita a leitura, evita duplica√ß√µes e melhora a organiza√ß√£o do c√≥digo.

---

### ‚ùå Errado (itens fora de ordem)

```tsx
import {
  footerMenuItems,
  mainMenuItems,
  MenuItem,
  StorageCard,
  UserCard,
} from './menu';
```

Os itens est√£o fora de ordem alfab√©tica, o que dificulta a visualiza√ß√£o r√°pida e pode gerar duplica√ß√µes acidentais.

### ‚úÖ Certo (ordenado alfabeticamente)

```tsx
import {
  MenuItem,
  StorageCard,
  UserCard,
  footerMenuItems,
  mainMenuItems,
} from './menu';
```

Importa√ß√µes organizadas de forma alfab√©tica, tornando o c√≥digo mais limpo e f√°cil de manter.

---

## üéØ Prompt: Exportando Componentes e Telas do Figma Usando Tailwind com Consist√™ncia

Sempre que estiver criando componentes ou telas com base em um design do Figma, **n√£o copie valores ao p√© da letra**.  
Antes de aplicar qualquer cor, tamanho, espa√ßamento, borda, tipografia, etc., verifique se esse valor j√° est√° **definido no tema do projeto** (ex: `globals.css`).  
Se estiver, **use o token do tema**. 
Se n√£o estiver, **use o valor mais pr√≥ximo** dispon√≠vel no design system.

---

### ‚úÖ Regras Gerais

- üîç **Verifique o tema (`globals.css`) antes de aplicar qualquer classe.**
- üé® **Use classes do Tailwind apenas com valores definidos no tema.**
- üß† **Se o valor no Figma for um pouco diferente (ex: `42px`) e n√£o existir no tema, escolha o valor mais pr√≥ximo** (ex: `40px`).
- ‚õî **Evite valores "m√°gicos" como `17px`, `#3A57E8`, `41.25px`, etc.**

---

### üí° Exemplo pr√°tico

**Design no Figma:**
- Cor: `#3A57E8`
- Altura do bot√£o: `42px`
- Padding horizontal: `18px`
- Border radius: `6px`
- Font size: `15px`
- Font weight: `500`

---

### ‚ùå Errado (copiando valores do Figma direto)

```tsx
<button
  style={{
    backgroundColor: '#3A57E8',
    height: '42px',
    padding: '10px 18px',
    borderRadius: '6px',
    fontSize: '15px',
    fontWeight: 500,
  }}
>
  Salvar
</button>
```

### ‚úÖ Certo (usando valores do tema no Tailwind)

```tsx
<button className="bg-primary h-10 px-4 py-2 rounded-md text-base font-medium">
  Salvar
</button>
```

| Propriedade        | Figma   | Tailwind Usado     | Justificativa                             |
| ------------------ | ------- | ------------------ | ----------------------------------------- |
| Cor                | #3A57E8 | `bg-primary`       | Cor j√° existe no tema                     |
| Altura             | 42px    | `h-10` (40px)      | Mais pr√≥ximo do valor no design system    |
| Padding horizontal | 18px    | `px-4` (16px)      | Valor padr√£o mais pr√≥ximo                 |
| Padding vertical   | 10px    | `py-2` (8px)       | Valor padr√£o mais pr√≥ximo                 |
| Border radius      | 6px     | `rounded-md`       | Valor equivalente no tema                 |
| Font size          | 15px    | `text-base` (16px) | 1px de diferen√ßa, sem impacto percept√≠vel |
| Font weight        | 500     | `font-medium`      | Valor correspondente                      |

---

Siga sempre as regras!